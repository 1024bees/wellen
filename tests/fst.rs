// Copyright 2024 The Regents of the University of California
// released under BSD 3-Clause License
// author: Kevin Laeufer <laeufer@berkeley.edu>
//
// test fst specific meta data

use std::collections::HashSet;
use wellen::*;

fn load_gtkwave_des() -> (Waveform, ScopeRef) {
    let filename = "inputs/gtkwave-analyzer/des.fst";
    let waves = fst::read(filename).expect("failed to parse");
    let h = waves.hierarchy();
    let top = h.first_scope().unwrap();
    assert_eq!("top", top.name(h));
    assert_eq!(Some(("des.v", 18)), top.source_loc(h));
    assert_eq!(Some(("des.v", 18)), top.instantiation_source_loc(h));
    let des_id = top.scopes(h).next().unwrap();
    let des = h.get(des_id);
    assert_eq!("des", des.name(h));
    (waves, des_id)
}

/// Loads a FST file that was generated by Icarus Verilog which annotates
/// scopes with the source location for both, their instance and their declaration.
#[test]
fn test_source_locators() {
    let (waves, des_id) = load_gtkwave_des();
    let h = waves.hierarchy();
    let des = h.get(des_id);

    let mut round_instance_lines = HashSet::new();
    for scope in des.scopes(h).map(|i| h.get(i)) {
        let name = scope.name(h);
        let (loc_path, loc_line) = scope.source_loc(h).expect("should have source loc");
        let (inst_path, inst_line) = scope
            .instantiation_source_loc(h)
            .expect("should have source loc");

        // everything is from a single `des.v` file
        assert_eq!(loc_path, "des.v");
        assert_eq!(inst_path, "des.v");

        // all round instances are from the same module
        if name.starts_with("round") {
            assert_eq!(loc_line, 991);
            assert!(!round_instance_lines.contains(&inst_line));
            round_instance_lines.insert(inst_line);
        }
    }
}

/// Loads a FST file that was generated by Icarus Verilog which _sometimes_ annotates
/// scopes with the name of the function or module that was instantiated.
#[test]
fn test_component_names() {
    let (waves, des_id) = load_gtkwave_des();
    let h = waves.hierarchy();
    let des = h.get(des_id);
    for scope in des.scopes(h).map(|i| h.get(i)) {
        let name = scope.name(h);

        // all rounds are instances of the same round_func
        if name.starts_with("round") {
            assert_eq!(scope.component(h).unwrap(), "roundfunc");
        }
    }
    let key_shed_id = des
        .scopes(h)
        .find(|s| h.get(*s).name(h) == "keysched")
        .unwrap();
    for scope in h.get(key_shed_id).scopes(h).map(|i| h.get(i)) {
        let name = scope.name(h);
        let comp = scope.component(h);
        if name == "pc1" {
            assert!(comp.is_none(), "{:?}", comp);
        } else if name.starts_with("pc2") {
            assert_eq!(comp.unwrap(), "pc2", "{:?}", comp);
        } else {
            let comp = comp.unwrap();
            assert!(comp == "rol1" || comp == "rol2", "{:?}", comp);
        }
    }
}

fn load_verilator_many_sv_datatypes() -> (Waveform, ScopeRef) {
    let filename = "inputs/verilator/many_sv_datatypes.fst";
    let waves = fst::read(filename).expect("failed to parse");
    let h = waves.hierarchy();
    let top = h.first_scope().unwrap();
    assert_eq!("TOP", top.name(h));
    let wrapper = h.get(top.scopes(h).next().unwrap());
    assert_eq!("SVDataTypeWrapper", wrapper.name(h));
    let bb_id = wrapper.scopes(h).next().unwrap();
    let bb = h.get(bb_id);
    assert_eq!("bb", bb.name(h));
    (waves, bb_id)
}

/// Loads a FST file that was generated by Verilator which annotates enum signals.
#[test]
fn test_enum_signals() {
    let (waves, bb_id) = load_verilator_many_sv_datatypes();
    let h = waves.hierarchy();
    let bb = h.get(bb_id);
    let abc_r = bb
        .vars(h)
        .map(|i| h.get(i))
        .find(|v| v.name(h) == "abc_r")
        .expect("failed to find abc_r");
    let mut enum_type = abc_r.enum_type(h).expect("abc_r should have an enum type!");
    assert_eq!(enum_type.0, "SVDataTypeBlackBox.abc");
    enum_type.1.sort();
    assert_eq!(
        enum_type.1,
        [("00", "A"), ("01", "B"), ("10", "C"), ("11", "D")]
    );
}

/// Loads a FST file that was generated by Verilator which contains variable directions.
#[test]
fn test_var_directions() {
    let (waves, bb_id) = load_verilator_many_sv_datatypes();
    let h = waves.hierarchy();
    let bb = h.get(bb_id);

    for var_ref in bb.vars(h) {
        let var = h.get(var_ref);
        let dt = (var.direction(), var.var_type());
        match var.name(h) {
            "abc_r" => assert_eq!(dt, (VarDirection::Implicit, VarType::Logic)),
            "clock" => assert_eq!(dt, (VarDirection::Input, VarType::Wire)),
            "int_r" => assert_eq!(dt, (VarDirection::Implicit, VarType::Integer)),
            "out" => assert_eq!(dt, (VarDirection::Output, VarType::Wire)),
            "real_r" => assert_eq!(dt, (VarDirection::Implicit, VarType::Real)),
            "time_r" => assert_eq!(dt, (VarDirection::Implicit, VarType::Bit)),
            other => todo!("{other} {dt:?}"),
        }
    }
}

#[test]
fn test_vhdl_ghdl() {
    let filename = "inputs/ghdl/oscar/ghdl.fst";
    let waves = fst::read(filename).expect("failed to parse");
    let h = waves.hierarchy();
    let ee = h.get(h.vars().next().unwrap());
    assert_eq!("ee", ee.name(h));
    assert_eq!(Some("e"), ee.vhdl_type_name(h)); // lol: VHDL is case insensitive!
}

#[test]
fn test_vhdl_3() {
    let filename = "inputs/ghdl/oscar/vhdl3.fst";
    let waves = fst::read(filename).expect("failed to parse");
    let h = waves.hierarchy();

    let top = h.first_scope().unwrap();
    assert_eq!("test", top.name(h));
    assert_eq!(top.scope_type(), ScopeType::VhdlArchitecture);

    let ee = h.get(top.vars(h).next().unwrap());
    assert_eq!("ee", ee.name(h));
    assert_eq!(Some("E"), ee.vhdl_type_name(h));

    let rr = h.get(top.scopes(h).next().unwrap());
    assert_eq!("rr", rr.name(h));
    assert_eq!(rr.source_loc(h), None);
    assert_eq!(rr.instantiation_source_loc(h), None);
    assert_eq!(rr.scope_type(), ScopeType::VhdlRecord);

    for var in rr.vars(h).map(|v| h.get(v)) {
        match var.name(h).chars().next().unwrap() {
            'a' => {
                assert_eq!(var.vhdl_type_name(h), Some("STD_LOGIC"));
                // TODO: this should be "Logic" and not "ULogic". Not sure why we end up with this though...
                assert_eq!(var.var_type(), VarType::StdULogic);
            }
            'b' | 'c' => {
                assert_eq!(var.vhdl_type_name(h), Some("STD_LOGIC_VECTOR"));
                assert_eq!(var.var_type(), VarType::StdLogicVector);
            }
            'd' => {
                assert_eq!(var.vhdl_type_name(h), Some("E"));
                assert_eq!(var.var_type(), VarType::String);
            }
            other => unreachable!("Unexpected var: {other}"),
        }
    }
}
