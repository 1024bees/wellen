// Copyright 2024 The Regents of the University of California
// released under BSD 3-Clause License
// author: Kevin Laeufer <laeufer@berkeley.edu>
//
// test fst specific meta data

use std::collections::HashSet;
use wellen::*;

/// Loads a FST file that was generated by Icarus Verilog which annotates
/// scopes with the source location for both, their instance and their declaration.
#[test]
fn test_source_locators() {
    let filename = "inputs/gtkwave-analyzer/des.fst";
    let waves = fst::read(filename).expect("failed to parse");
    let h = waves.hierarchy();
    let top = h.first_scope().unwrap();
    assert_eq!("top", top.name(h));
    assert_eq!(Some(("des.v", 18)), top.source_loc(h));
    assert_eq!(Some(("des.v", 18)), top.instantiation_source_loc(h));
    let des = h.get(top.scopes(h).next().unwrap());
    assert_eq!("des", des.name(h));
    let mut round_instance_lines = HashSet::new();
    for scope in des.scopes(h).map(|i| h.get(i)) {
        let name = scope.name(h);
        let (loc_path, loc_line) = scope.source_loc(h).expect("should have source loc");
        let (inst_path, inst_line) = scope
            .instantiation_source_loc(h)
            .expect("should have source loc");

        // everything is from a single `des.v` file
        assert_eq!(loc_path, "des.v");
        assert_eq!(inst_path, "des.v");

        // all round instances are from the same module
        if name.starts_with("round") {
            assert_eq!(loc_line, 991);
            assert!(!round_instance_lines.contains(&inst_line));
            round_instance_lines.insert(inst_line);
        }
    }
}
