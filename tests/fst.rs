// Copyright 2024 The Regents of the University of California
// released under BSD 3-Clause License
// author: Kevin Laeufer <laeufer@berkeley.edu>
//
// test fst specific meta data

use std::collections::HashSet;
use wellen::*;

/// Loads a FST file that was generated by Icarus Verilog which annotates
/// scopes with the source location for both, their instance and their declaration.
#[test]
fn test_source_locators() {
    let filename = "inputs/gtkwave-analyzer/des.fst";
    let waves = fst::read(filename).expect("failed to parse");
    let h = waves.hierarchy();
    let top = h.first_scope().unwrap();
    assert_eq!("top", top.name(h));
    assert_eq!(Some(("des.v", 18)), top.source_loc(h));
    assert_eq!(Some(("des.v", 18)), top.instantiation_source_loc(h));
    let des = h.get(top.scopes(h).next().unwrap());
    assert_eq!("des", des.name(h));
    let mut round_instance_lines = HashSet::new();
    for scope in des.scopes(h).map(|i| h.get(i)) {
        let name = scope.name(h);
        let (loc_path, loc_line) = scope.source_loc(h).expect("should have source loc");
        let (inst_path, inst_line) = scope
            .instantiation_source_loc(h)
            .expect("should have source loc");

        // everything is from a single `des.v` file
        assert_eq!(loc_path, "des.v");
        assert_eq!(inst_path, "des.v");

        // all round instances are from the same module
        if name.starts_with("round") {
            assert_eq!(loc_line, 991);
            assert!(!round_instance_lines.contains(&inst_line));
            round_instance_lines.insert(inst_line);
        }
    }
}

/// Loads a FST file that was generated by Verilator which annotates enum signals.
#[test]
fn test_enum_signals() {
    let filename = "inputs/verilator/many_sv_datatypes.fst";
    let waves = fst::read(filename).expect("failed to parse");
    let h = waves.hierarchy();
    let top = h.first_scope().unwrap();
    assert_eq!("TOP", top.name(h));
    let wrapper = h.get(top.scopes(h).next().unwrap());
    assert_eq!("SVDataTypeWrapper", wrapper.name(h));
    let bb = h.get(wrapper.scopes(h).next().unwrap());
    assert_eq!("bb", bb.name(h));
    let abc_r = bb
        .vars(h)
        .map(|i| h.get(i))
        .find(|v| v.name(h) == "abc_r")
        .expect("failed to find abc_r");
    let mut enum_type = abc_r.enum_type(h).expect("abc_r should have an enum type!");
    assert_eq!(enum_type.0, "SVDataTypeBlackBox.abc");
    enum_type.1.sort();
    assert_eq!(
        enum_type.1,
        [("00", "A"), ("01", "B"), ("10", "C"), ("11", "D")]
    );
}
